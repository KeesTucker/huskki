package web

import (
	"huskki/config"
	"huskki/events"
	"huskki/web"
	"log"
	"net/http"
	"time"

	ds "github.com/starfederation/datastar-go/datastar"
)

type Server struct {
	renderer Renderer
	eventHub *events.EventHub
	handler  *http.ServeMux
}

func NewServer(renderer Renderer, eventHub *events.EventHub) *Server {
	s := &Server{
		renderer: renderer,
		eventHub: eventHub,
	}

	handler := http.NewServeMux()
	handler.HandleFunc("/", s.IndexHandler)
	handler.HandleFunc("/events", s.EventsHandler)
	handler.HandleFunc("/time", s.TimeHandler)
	handler.Handle("/static/", http.FileServer(http.FS(web.Static)))

	for path, uiHandler := range renderer.Handlers() {
		handler.HandleFunc(path, uiHandler)
	}

	s.handler = handler

	return s
}

func (s *Server) Start(addr string) error {
	log.Printf("listening on %s â€¦", addr)
	return http.ListenAndServe(addr, s.handler)
}

// IndexHandler is the main entrypoint for the UI
func (s *Server) IndexHandler(w http.ResponseWriter, _ *http.Request) {
	err := s.renderer.Templates().ExecuteTemplate(w, "index", s.renderer.Data())
	if err != nil {
		log.Printf("couldn't execute template for index %s", err)
		w.WriteHeader(http.StatusInternalServerError)
	}
}

// EventsHandler is called on page load and pushes page changes to the client via SSE,
// based on events generated by the Huskki input source (live / replay)
func (s *Server) EventsHandler(w http.ResponseWriter, r *http.Request) {
	sse := ds.NewSSE(w, r)

	_, ch, cancel := s.eventHub.Subscribe()
	defer cancel()

	for {
		select {
		case <-r.Context().Done():
			continue
		case event := <-ch:
			updateFunc := s.renderer.GeneratePatchOnEvent(event)
			if updateFunc != nil {
				err := updateFunc(sse)
				log.Printf("end patch")
				if err != nil {
					log.Printf("error updating template for event: %s", err)
					w.WriteHeader(http.StatusInternalServerError)
					continue
				}
			}
		}
	}
}

func (s *Server) TimeHandler(w http.ResponseWriter, r *http.Request) {
	sse := ds.NewSSE(w, r)

	ctx := r.Context()
	ticker := time.NewTicker(1000 / config.DASHBOARD_FRAMERATE * time.Millisecond)
	defer ticker.Stop()

	for {
		select {
		case <-ctx.Done():
			continue
		case tick := <-ticker.C:
			err := s.renderer.OnTick(sse, int(tick.UnixMilli()))
			if err != nil {
				log.Printf("error updating template for time event: %s", err)
				continue
			}
		}
	}
}
