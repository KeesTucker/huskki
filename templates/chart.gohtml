{{ define "chart" }}

    <div class="card"
        data-on-click__throttle.200ms="
            $chart = { key: '{{ .Key }}' };
            @post('/toggle-active-stream', { filterSignals: { include: /^chart\./ } })"
    >
    {{ template "activeStream.title" . }}
    <div class="value">
        {{ template "activeStream.value" . }}
        {{ template "activeStream.unit" . }}
    </div>
    <div class="chart-container">
      <canvas id="{{ .Key }}-chart"></canvas>
    </div>
</div>
<script>
    // Set the “zero” point for the chart timeline
    window['{{ .Key }}StartTime'] = Date.now();
    // Each chart has its own data buffer
    {{ range $s := .Streams }}
    window['{{ $s.Key }}Buffer'] = [];
    {{ end }}

    new Chart(document.getElementById("{{ .Key }}-chart"), {
        type: "line",
        data: {
            {{ $chart := . }}
            datasets: [
                {{ range $i, $s := .Streams }}
                {
                    label: "{{ $s.Description }}",
                    borderColor: "{{ $s.Color }}",
                    borderWidth: {{ if eq $i $chart.ActiveStream }}3{{ else }}0{{ end }},
                    backgroundColor: "{{ $s.Color }}A0",
                    data: [],
                    fill: true,
                    parsing: false,
                    pointRadius: 0
                },
                {{ end }}
            ]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                legend: {
                    display: false
                },
                title: {
                    display: false
                },
            },
            layout: {
                padding: {
                  // Remove the annoying padding on the axis
                  left: -10,
                  bottom: -10
                }
            },
            scales: {
                y: {
                    ticks: {
                        display: false
                    },
                    grid: {
                        display: false,
                    },
                    borders: {
                        display: false
                    },
                    beginAtZero: true,
                    max: {{ .Max }}
                },
                x: {
                    ticks: {
                        display: false
                    },
                    grid: {
                        display: false,
                    },
                    borders: {
                        display: false
                    },
                    type: 'realtime',
                    realtime: {
                        duration: {{ .Duration }},
                        refresh: 10,
                        delay: 0,
                        frameRate: 30,
                        time: { now: () => Date.now() },
                        onRefresh: (chart) => {
                            const MAX_POINTS = 2000;
                            const ALPHA = 0.5;   // EMA smoothing for non-discrete
                            const FILL_MS = 100; // discrete hold interval

                            // Per-dataset meta by index (generated from template)
                            const metaByIndex = [
                                {{- range $i, $s := .Streams }}
                                { key: "{{ $s.Key }}", discrete: {{ $s.Discrete }} },
                                {{- end }}
                            ];

                            const rightTime = Date.now();

                            chart.data.datasets.forEach((ds, i) => {
                                const meta = metaByIndex[i] || {};
                                const buff = window[meta.key + 'Buffer'] || [];

                                // Ensure per-dataset state fields exist
                                if (ds._nextFillX === undefined) ds._nextFillX = null;
                                if (ds._discreteActive === undefined) ds._discreteActive = false;
                                if (ds._lastDiscreteY === undefined) ds._lastDiscreteY = undefined;
                                if (ds._ema === undefined) ds._ema = undefined;
                                if (ds._sentinel === undefined) ds._sentinel = null;

                                // Drain this stream's buffer
                                while (buff.length) {
                                    const raw = buff.shift(); // { x, y } where x is ms epoch
                                    const insertIdx = ds._sentinel ? ds.data.length - 1 : ds.data.length;

                                    if (meta.discrete) {
                                        // Discrete: no smoothing, hold-last behavior handled below
                                        ds.data.splice(insertIdx, 0, { x: raw.x, y: raw.y });
                                        ds._ema = undefined;
                                        ds._nextFillX = Math.max(ds._nextFillX ?? (raw.x + FILL_MS), raw.x + FILL_MS);
                                        ds._discreteActive = true;
                                        ds._lastDiscreteY = raw.y;
                                    } else {
                                        // Continuous: EMA smoothing
                                        ds._ema = (ds._ema == null) ? raw.y : (ALPHA * raw.y + (1 - ALPHA) * ds._ema);
                                        ds.data.splice(insertIdx, 0, { x: raw.x, y: ds._ema });
                                        ds._discreteActive = false;
                                        ds._nextFillX = null;
                                        ds._lastDiscreteY = undefined;
                                    }
                                }

                                // If in discrete mode, fill every FILL_MS with last Y up to now
                                const realCount = ds.data.length - (ds._sentinel ? 1 : 0);
                                const lastReal = realCount > 0 ? ds.data[realCount - 1] : null;

                                if (ds._discreteActive && lastReal) {
                                    ds._lastDiscreteY = lastReal.y;
                                    if (ds._nextFillX == null) ds._nextFillX = lastReal.x + FILL_MS;

                                    let insertIdx = ds._sentinel ? ds.data.length - 1 : ds.data.length;
                                    while (ds._nextFillX <= rightTime) {
                                        ds.data.splice(insertIdx, 0, { x: ds._nextFillX, y: ds._lastDiscreteY });
                                        insertIdx++;
                                        ds._nextFillX += FILL_MS;
                                    }
                                }

                                // Maintain a single sentinel pinned to the right edge, matching last real Y
                                if (lastReal) {
                                    if (!ds._sentinel) {
                                        const s = { x: rightTime, y: lastReal.y, _sentinel: true };
                                        ds.data.push(s);
                                        ds._sentinel = s;
                                    } else {
                                        ds._sentinel.x = rightTime;
                                        ds._sentinel.y = lastReal.y;
                                    }
                                } else if (ds._sentinel) {
                                    ds.data.pop();
                                    ds._sentinel = null;
                                }

                                // Trim old real points but never drop the sentinel
                                const over = (ds.data.length - (ds._sentinel ? 1 : 0)) - MAX_POINTS;
                                if (over > 0) ds.data.splice(0, over);
                            });
                        }
                    }
                }
            }
        }
    });
</script>
{{ end }}

{{ define "activeStream.title" }}
    <h4 id="{{ .Key }}-title" class="title">{{ (index .Streams .ActiveStream).Key }}</h4>
{{ end }}

{{ define "activeStream.value" }}
    <span id="{{ .Key }}-value">{{ (index .Streams .ActiveStream).Value }}</span>
{{ end }}

{{ define "activeStream.unit" }}
    <span id="{{ .Key }}-unit" class="unit">{{ (index .Streams .ActiveStream).Unit }}</span>
{{ end }}