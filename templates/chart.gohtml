{{ define "chart" }}

    <div class="card"
        data-on-click__throttle.200ms="
            $chart = { key: '{{ .Key }}' };
            @post('/toggle-active-stream', { filterSignals: { include: /^chart\./ } })"
    >
    {{ template "activeStream.title" . }}
    <div class="value">
        {{ template "activeStream.value" . }}
        {{ template "activeStream.unit" . }}
    </div>
    <div class="chart-container">
      <canvas id="{{ .Key }}-chart"></canvas>
    </div>
</div>
<script>
    // Set the “zero” point for the chart timeline
    window['{{ .Key }}StartTime'] = Date.now();
    // Each chart stream has its own data buffer
    {{ range $s := .Streams }}
    window['{{ $s.Key }}Buffer'] = [];
    {{ end }}

    // Janky gradient plugin
    (function () {
        function withAlpha(color, alpha) {
            if (typeof color === 'string' && color[0] === '#') {
                var r = parseInt(color.slice(1,3),16);
                var g = parseInt(color.slice(3,5),16);
                var b = parseInt(color.slice(5,7),16);
                return 'rgba(' + r + ',' + g + ',' + b + ',' + alpha + ')';
            }
            if (typeof color === 'string' && color.indexOf('rgb') === 0) {
                return color.replace(/rgba?\(([^)]+)\)/, function(_, inner){
                    var p = inner.split(',').map(function(s){return s.trim();});
                    return 'rgba(' + p[0] + ',' + p[1] + ',' + p[2] + ',' + alpha + ')';
                });
            }
            return color;
        }

        function buildGradient(ctx, area, stops) {
            var g = ctx.createLinearGradient(0, area.bottom, 0, area.top);
            // stops can be ["#..","#.."] or [{o:0,color:"#.."}, ...]
            if (!stops || !stops.length) return g;
            var i, n = stops.length;
            if (typeof stops[0] === 'string') {
                // even spacing
                for (i = 0; i < n; i++) {
                    var off = (n === 1) ? 0 : (i / (n - 1));
                    g.addColorStop(off, stops[i]);
                }
            } else {
                for (i = 0; i < n; i++) {
                    var off2 = Math.max(0, Math.min(1, stops[i].o != null ? stops[i].o : stops[i].offset));
                    var col2 = stops[i].c || stops[i].color;
                    g.addColorStop(off2, col2);
                }
            }
            return g;
        }

        function buildGradientWithAlpha(ctx, area, stops, alpha) {
            // apply alpha to each stop color
            var arr, i, n;
            if (!stops || !stops.length) return buildGradient(ctx, area, stops);
            if (typeof stops[0] === 'string') {
                arr = [];
                n = stops.length;
                for (i = 0; i < n; i++) arr.push(withAlpha(stops[i], alpha));
                return buildGradient(ctx, area, arr);
            } else {
                arr = [];
                n = stops.length;
                for (i = 0; i < n; i++) {
                    arr.push({ o: (stops[i].o != null ? stops[i].o : stops[i].offset), c: withAlpha(stops[i].c || stops[i].color, alpha) });
                }
                return buildGradient(ctx, area, arr);
            }
        }

        // Register a lightweight plugin that (re)computes gradients after layout
        window.StreamGradientPlugin = {
            id: 'streamGradient',
            beforeDatasetsDraw: function (chart) {
                var area = chart.chartArea;
                if (!area) return;
                var ctx = chart.ctx;
                var meta = chart.$streamGradientMeta || {};
                var activeIndex = (chart.options.plugins && chart.options.plugins.streamGradient)
                    ? chart.options.plugins.streamGradient.activeIndex : 0;
                var stopsByIndex = (chart.options.plugins && chart.options.plugins.streamGradient)
                    ? chart.options.plugins.streamGradient.stopsByIndex : [];

                for (var i = 0; i < chart.data.datasets.length; i++) {
                    var ds = chart.data.datasets[i];
                    var stops = stopsByIndex[i] || [];
                    // border = solid gradient; background = gradient with alpha (active vs inactive)
                    ds.borderColor = buildGradient(ctx, area, stops);

                    var a = (i === activeIndex) ? 0.7 : 0.5; // active less see-through, inactive more see-through
                    ds.backgroundColor = buildGradientWithAlpha(ctx, area, stops, a);
                }
                chart.$streamGradientMeta = meta;
            }
        };

        // Auto-register if Chart is present
        if (window.Chart && window.Chart.register) {
            window.Chart.register(window.StreamGradientPlugin);
        }
    })()

    new Chart(document.getElementById("{{ .Key }}-chart"), {
        type: "line",
        data: {
            {{ $chart := . }}
            datasets: [
                {{ range $i, $s := .Streams }}
                {
                    label: "{{ $s.Description }}",
                    borderWidth: {{ if eq $i $chart.ActiveStream }}3{{ else }}0{{ end }},
                    data: [ { x: Date.now(), y: 0 } ],
                    fill: true,
                    parsing: false,
                    pointRadius: 0
                },
                {{ end }}
            ]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            interaction: {
                mode: 'none'
            },
            plugins: {
                legend: {
                    display: false
                },
                title: {
                    display: false
                },
                tooltip: {
                    enabled: false
                },
                streamGradient: {
                    activeIndex: {{ .ActiveStream }},
                    // stops per dataset (bottom→top). We’ll space them evenly.
                    stopsByIndex: [
                        {{- range $i, $s := .Streams }}
                        [ {{- range $j, $c := $s.Colours -}}"{{ $c }}",{{- end }} ],
                        {{- end }}
                    ]
                }
            },
            layout: {
                padding: {
                  // Remove the annoying padding on the axis
                  left: -10,
                  bottom: -10
                }
            },
            scales: {
                y: {
                    ticks: {
                        display: false
                    },
                    grid: {
                        display: false,
                    },
                    borders: {
                        display: false
                    },
                    beginAtZero: true,
                    max: {{ .Max }}
                },
                x: {
                    ticks: {
                        display: false
                    },
                    grid: {
                        display: false,
                    },
                    borders: {
                        display: false
                    },
                    type: 'realtime',
                    realtime: {
                        duration: {{ .Duration }},
                        refresh: 10,
                        delay: 0,
                        frameRate: 30,
                        time: { now: () => Date.now() },
                        onRefresh: (chart) => {
                            const currentTime = Date.now();
                            const MAX_POINTS = 2000;
                            const ALPHA = 0.5;   // EMA smoothing for non-discrete
                            const FILL_MS = 100; // discrete hold interval

                            // Per-dataset meta by index (generated from template)
                            const metaByIndex = [
                                {{- range $i, $s := .Streams }}
                                { key: "{{ $s.Key }}", discrete: {{ $s.Discrete }}, smoothing: {{ $s.Smoothing }} },
                                {{- end }}
                            ];

                            chart.data.datasets.forEach((ds, i) => {
                                const meta = metaByIndex[i] || {};
                                const buff = window[meta.key + 'Buffer'] || [];

                                // Ensure per-dataset state fields exist
                                if (ds._nextFillX === undefined) ds._nextFillX = null;
                                if (ds._discreteActive === undefined) ds._discreteActive = false;
                                if (ds._lastDiscreteY === undefined) ds._lastDiscreteY = undefined;
                                if (ds._ema === undefined) ds._ema = undefined;
                                if (ds._sentinel === undefined) ds._sentinel = null;

                                // Drain this stream's buffer
                                while (buff.length) {
                                    const raw = buff.shift(); // { x, y } where x is ms epoch
                                    const insertIdx = ds._sentinel ? ds.data.length - 1 : ds.data.length;

                                    if (meta.discrete) {
                                        // Discrete: no smoothing, hold-last behavior handled below
                                        ds.data.splice(insertIdx, 0, { x: raw.x, y: raw.y });
                                        ds._ema = undefined;
                                        ds._nextFillX = Math.max(ds._nextFillX ?? (raw.x + FILL_MS), raw.x + FILL_MS);
                                        ds._discreteActive = true;
                                        ds._lastDiscreteY = raw.y;
                                    } else if (meta.smoothing) {
                                        // Continuous: EMA smoothing
                                        ds._ema = (ds._ema == null) ? raw.y : (ALPHA * raw.y + (1 - ALPHA) * ds._ema);
                                        ds.data.splice(insertIdx, 0, { x: raw.x, y: ds._ema });
                                        ds._discreteActive = false;
                                        ds._nextFillX = null;
                                        ds._lastDiscreteY = undefined;
                                    } else {
                                        // Raw representation
                                        ds.data.splice(insertIdx, 0, { x: raw.x, y: raw.y });
                                        ds._discreteActive = false;
                                        ds._nextFillX = null;
                                        ds._lastDiscreteY = undefined;
                                    }
                                }

                                // If in discrete mode, fill every FILL_MS with last Y up to now
                                const realCount = ds.data.length - (ds._sentinel ? 1 : 0);
                                const lastReal = realCount > 0 ? ds.data[realCount - 1] : null;

                                if (ds._discreteActive && lastReal) {
                                    ds._lastDiscreteY = lastReal.y;
                                    if (ds._nextFillX == null) ds._nextFillX = lastReal.x + FILL_MS;

                                    let insertIdx = ds._sentinel ? ds.data.length - 1 : ds.data.length;
                                    while (ds._nextFillX <= currentTime) {
                                        ds.data.splice(insertIdx, 0, { x: ds._nextFillX, y: ds._lastDiscreteY });
                                        insertIdx++;
                                        ds._nextFillX += FILL_MS;
                                    }
                                }

                                // Maintain a single sentinel pinned to the right edge, matching last real Y
                                if (lastReal) {
                                    if (!ds._sentinel) {
                                        const s = { x: currentTime, y: lastReal.y, _sentinel: true };
                                        ds.data.push(s);
                                        ds._sentinel = s;
                                    } else {
                                        ds._sentinel.x = currentTime;
                                        ds._sentinel.y = lastReal.y;
                                    }
                                } else if (ds._sentinel) {
                                    ds.data.pop();
                                    ds._sentinel = null;
                                }

                                // Trim old real points but never drop the sentinel
                                const over = (ds.data.length - (ds._sentinel ? 1 : 0)) - MAX_POINTS;
                                if (over > 0) ds.data.splice(0, over);
                            });
                        }
                    }
                }
            }
        }
    });
</script>
{{ end }}

{{ define "activeStream.title" }}
    <h4 id="{{ .Key }}-title" class="title">{{ (index .Streams .ActiveStream).Key }}</h4>
{{ end }}

{{ define "activeStream.value" }}
    <span id="{{ .Key }}-value">{{ (index .Streams .ActiveStream).Value }}</span>
{{ end }}

{{ define "activeStream.unit" }}
    <span id="{{ .Key }}-unit" class="unit">{{ (index .Streams .ActiveStream).Unit }}</span>
{{ end }}