package main

import "C"
import (
	"fmt"
	"huskki/hub"
	"log"
	"net/http"
	"strings"
	"time"

	ds "github.com/starfederation/datastar-go/datastar"
)

type stream struct {
	Key         string
	Description string
	Value       any
	Unit        string
	Discrete    bool
	Smoothing   bool
	Colours     []string
}

type chart struct {
	Key          string
	Streams      []*stream
	ActiveStream uint8
	Duration     int
	Max          any
}

type cycleActiveChartSig struct {
	Chart struct {
		Key string `json:"key"`
	} `json:"chart"`
}

const (
	THROTTLE_STREAM       = "Computed Throttle"
	GRIP_STREAM           = "Input Throttle"
	TPS_STREAM            = "TPS"
	RPM_STREAM            = "RPM"
	GEAR_STREAM           = "Gear"
	COOLANT_STREAM        = "Coolant"
	INJECTION_TIME_STREAM = "Injection Time"
)

const (
	THROTTLE_CHART  = "Throttle"
	RPM_CHART       = "RPM"
	GEAR_CHART      = "Gear"
	COOLANT_CHART   = "Coolant"
	INJECTION_CHART = "Injection"
)

var streams = map[string]*stream{
	THROTTLE_STREAM:       {THROTTLE_STREAM, "ECU computed throttle", 0, "%", false, true, []string{"#FF0000"}},
	GRIP_STREAM:           {GRIP_STREAM, "Rider throttle input", 0, "%", false, true, []string{"#00FF00"}},
	TPS_STREAM:            {TPS_STREAM, "Throttle plate sensor", 0, "%", false, true, []string{"#0000FF"}},
	RPM_STREAM:            {RPM_STREAM, "Engine rotational speed", 0, "rpm", false, true, []string{"#FFFFFF"}},
	GEAR_STREAM:           {GEAR_STREAM, "Transmission Gear", 0, "", true, true, []string{"#FFFFFF"}},
	COOLANT_STREAM:        {COOLANT_STREAM, "Coolant temperature", 0, "Â°C", false, false, []string{"#0000FF", "#00FF00", "#FF0000"}},
	INJECTION_TIME_STREAM: {INJECTION_TIME_STREAM, "Injector pulse width", 0, "ms", false, true, []string{"#FFFFFF"}},
}

var charts = map[string]*chart{
	THROTTLE_CHART:  {THROTTLE_CHART, []*stream{streams[THROTTLE_STREAM], streams[GRIP_STREAM], streams[TPS_STREAM]}, 2, 10000, 100},
	RPM_CHART:       {RPM_CHART, []*stream{streams[RPM_STREAM]}, 0, 10000, 10000},
	GEAR_CHART:      {GEAR_CHART, []*stream{streams[GEAR_STREAM]}, 0, 10000, 6},
	COOLANT_CHART:   {COOLANT_CHART, []*stream{streams[COOLANT_STREAM]}, 0, 300000, 120},
	INJECTION_CHART: {INJECTION_CHART, []*stream{streams[INJECTION_TIME_STREAM]}, 0, 10000, 15},
}

var _chartsByStreamKey map[string]*chart

// IndexHandler is the main entrypoint for the UI
func IndexHandler(w http.ResponseWriter, _ *http.Request) {
	err := Templates.ExecuteTemplate(w, "index", map[string]interface{}{
		"charts": charts,
	})
	if err != nil {
		log.Printf("couldn't execute template for index %s", err)
		w.WriteHeader(http.StatusInternalServerError)
	}
}

// EventsHandler is called on page load and pushes page changes to the client via SSE,
// based on events generated by the Huskki input source (live / replay)
func EventsHandler(w http.ResponseWriter, r *http.Request) {
	sse := ds.NewSSE(w, r)

	_, ch, cancel := EventHub.Subscribe()
	defer cancel()

	for {
		select {
		case <-r.Context().Done():
			return
		case event := <-ch:
			updateFunc := generatePatch(event)
			if updateFunc != nil {
				err := updateFunc(sse)
				if err != nil {
					log.Printf("error updating template for event: %s", err)
					w.WriteHeader(http.StatusInternalServerError)
					return
				}
			}
		}
	}
}

func TimeHandler(w http.ResponseWriter, r *http.Request) {
	sse := ds.NewSSE(w, r)

	ctx := r.Context()
	ticker := time.NewTicker(1 * time.Second)
	defer ticker.Stop()

	// Yeet an initial value to the client
	_ = sse.MarshalAndPatchSignals(map[string]any{
		"t": time.Now().UnixMilli(),
	})

	for {
		select {
		case <-ctx.Done():
			return
		case tick := <-ticker.C:
			// Push the server time as a Datastar signal
			if err := sse.MarshalAndPatchSignals(map[string]any{
				"t": tick.UnixMilli(),
			}); err != nil {
				log.Printf("error patching signal with time: %s", err)
				return
			}
		}
	}
}

// CycleStreamHandler is called when the client clicks on a chart to switch the active stream
func CycleStreamHandler(w http.ResponseWriter, r *http.Request) {
	// Read signals sent from the client
	var sig cycleActiveChartSig
	if err := ds.ReadSignals(r, &sig); err != nil {
		log.Printf("error reading signals: %s", err)
		w.WriteHeader(http.StatusBadRequest)
		return
	}

	// Find the chart by key
	c := charts[sig.Chart.Key]
	if c == nil || len(c.Streams) == 0 {
		log.Printf("chart not found or no streams present %s", sig.Chart.Key)
		w.WriteHeader(http.StatusNotFound)
		return
	}

	// Cycle active stream
	c.ActiveStream = (c.ActiveStream + 1) % uint8(len(c.Streams))

	var buf strings.Builder
	err := Templates.ExecuteTemplate(&buf, "activeStream.title", c)
	if err != nil {
		log.Printf("couldn't execute active stream title template %s", err)
		w.WriteHeader(http.StatusInternalServerError)
	}
	err = Templates.ExecuteTemplate(&buf, "activeStream.value", c)
	if err != nil {
		log.Printf("couldn't execute active stream value template %s", err)
		w.WriteHeader(http.StatusInternalServerError)
	}
	err = Templates.ExecuteTemplate(&buf, "activeStream.unit", c)
	if err != nil {
		log.Printf("couldn't execute active stream unit template %s", err)
		w.WriteHeader(http.StatusInternalServerError)
	}

	sse := ds.NewSSE(w, r)
	if buf.String() != "" {
		_ = sse.PatchElements(buf.String()) // morphs the target element by ID
	}

	err = sse.ExecuteScript(buildCycleStreamChartScript(c.Key, c.ActiveStream))
	if err != nil {
		log.Printf("couldn't execute script to update chart colours %s", err)
		w.WriteHeader(http.StatusInternalServerError)
	}
}

func buildUpdateChartScript(chartKey, streamKey string, x int, y float64) string {
	return fmt.Sprintf(`pushData("%s", "%s", %d, %f);`, chartKey, streamKey, x, y)
}

func buildCycleStreamChartScript(chartKey string, activeStream uint8) string {
	return fmt.Sprintf(`cycleStream("%s", %d);`,
		chartKey,
		activeStream,
	)
}

// generatePatch takes an event received from the event queue, iterates the charts that are displayed on the UI,
// and returns a closure that can be used to patch the client.
func generatePatch(event *hub.Event) func(*ds.ServerSentEventGenerator) error {

	var writer = strings.Builder{}
	var funcs []func(generator *ds.ServerSentEventGenerator) error

	c, ok := ChartsByStreamKey()[event.StreamKey]
	if !ok {
		log.Printf("chart not found for stream %s", event.StreamKey)
		return nil
	}

	s, ok := streams[event.StreamKey]
	if !ok {
		log.Printf("stream not found %s", event.StreamKey)
		return nil
	}

	var v float64
	switch event.Value.(type) {
	case int:
		v = float64(event.Value.(int))
	case float64:
		v = event.Value.(float64)
	default:
		log.Printf("error bad event value type %T", event.Value)
		return nil
	}

	// Check if this is the active stream
	if c.Streams[c.ActiveStream] == s {
		s.Value = fmt.Sprintf("%v", event.Value)
		// Update chart value
		err := Templates.ExecuteTemplate(&writer, "activeStream.value", c)
		if err != nil {
			log.Printf("error executing template: %s", err)
		}
	}

	// Update graphs
	funcs = append(funcs, func(sse *ds.ServerSentEventGenerator) error {
		err := sse.ExecuteScript(buildUpdateChartScript(c.Key, s.Key, event.Timestamp, v))
		if err != nil {
			log.Printf("error executing script to update chart %s", err)
		}
		return err
	})

	// Main closure
	return func(sse *ds.ServerSentEventGenerator) error {
		// Patch UI elements
		if writer.String() != "" {
			err := sse.PatchElements(writer.String())
			if err != nil {
				return err
			}
		}

		// Exec client-side javascript
		for _, f := range funcs {
			err := f(sse)
			if err != nil {
				return err
			}
		}

		return nil
	}
}

func ChartsByStreamKey() map[string]*chart {
	if _chartsByStreamKey == nil || len(_chartsByStreamKey) == 0 {
		_chartsByStreamKey = make(map[string]*chart)
		for _, c := range charts {
			for _, s := range c.Streams {
				_chartsByStreamKey[s.Key] = c
			}
		}
	}

	return _chartsByStreamKey
}
