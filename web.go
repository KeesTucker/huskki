package main

import (
	"fmt"
	"net/http"
	"strings"

	ds "github.com/starfederation/datastar-go/datastar"
)

const (
	DISABLE_CHARTS = false
)

type cardProps struct {
	Name  string
	Value any
	Unit  string
}

var cards = []cardProps{
	{"Throttle", 0, "%"},
	{"RPM", 0, "RPM"},
	{"Gear", 0, ""},
	//{"Clutch", 0, "HEX"},
	{"Coolant", 0, "Â°C"},
	//{"Grip", 0, "%"},
	//{"TPS", 0, "%"},
}

type chartProps struct {
	Name        string
	Description string
}

var charts = []chartProps{
	{"Throttle", "Computed throttle as %"},
	{"RPM", "Engine speed in Revolutions Per Minute"},
	//{"Gear", "Transmission gear"},
	{"Coolant", "Coolant temperature in celsius"},
	{"Injection Time", "Injector pulse width in milliseconds"},
	//{"Grip", "Rider throttle input in %"},
	//{"TPS", "Throttle plate sensor in %"},
}

// IndexHandler is the main entrypoint for the UI
func IndexHandler(w http.ResponseWriter, _ *http.Request) {
	err := Templates.ExecuteTemplate(w, "index", map[string]interface{}{
		"cards":         cards,
		"chartsEnabled": !DISABLE_CHARTS,
		"charts":        charts,
	})
	if err != nil {
		fmt.Println(err)
		w.WriteHeader(http.StatusInternalServerError)
	}
}

// EventsHandler is called on page load and pushes page changes to the client via SSE,
// based on events generated by the Huskki input source (live / replay)
func EventsHandler(w http.ResponseWriter, r *http.Request) {
	sse := ds.NewSSE(w, r)

	_, ch, cancel := EventHub.Subscribe()
	defer cancel()

	for {
		select {
		case <-r.Context().Done():
			return
		case event := <-ch:
			updateFunc := generatePatch(event)
			err := updateFunc(sse)
			if err != nil {
				fmt.Println(err)
				w.WriteHeader(http.StatusInternalServerError)
				return
			}
		}
	}
}

func buildUpdateChartScript(name string, x int, y float64, discrete bool) string {
	return fmt.Sprintf(`pushData("%s", %d, %f, %t);`, strings.ToLower(name), x, y, discrete)
}

// generatePatch takes an event received from the event queue, iterates the cards that are displayed on the UI,
// and returns a closure that can be used to patch the client.
func generatePatch(event map[string]any) func(*ds.ServerSentEventGenerator) error {

	var writer = strings.Builder{}
	var funcs []func(generator *ds.ServerSentEventGenerator) error

	// For each card, see if we have an update and template a response
	for _, card := range cards {
		if value, ok := event[strings.ToLower(card.Name)]; ok {
			err := Templates.ExecuteTemplate(&writer, "card.value", cardProps{Name: card.Name, Value: fmt.Sprintf("%v", value)})
			if err != nil {
				fmt.Printf("executing template: %v", err)
			}
		}
	}

	// For each chart see if we have an update and form an SSE update function
	for _, chart := range charts {
		if DISABLE_CHARTS {
			continue
		}
		value, ok := event[strings.ToLower(chart.Name)]
		if !ok {
			continue
		}
		timestamp, ok := event["timestamp"]
		if !ok {
			continue
		}
		discrete := event["discrete"]

		var v float64
		switch value.(type) {
		case int:
			v = float64(value.(int))
		case float64:
			v = value.(float64)
		default:
			continue
		}

		ts, ok := timestamp.(int)
		if !ok {
			continue
		}
		var d bool
		d, ok = discrete.(bool)
		if ok && d {
			d = true
		}

		funcs = append(funcs, func(sse *ds.ServerSentEventGenerator) error {
			err := sse.ExecuteScript(buildUpdateChartScript(chart.Name, ts, v, d))
			return err
		})
	}

	// Main closure
	return func(sse *ds.ServerSentEventGenerator) error {
		// Patch UI elements
		if writer.String() != "" {
			err := sse.PatchElements(writer.String())
			if err != nil {
				return err
			}
		}

		// Exec client-side javascript
		for _, f := range funcs {
			err := f(sse)
			if err != nil {
				return err
			}
		}

		return nil
	}
}
